# 第三章 数据特性

相关主题如下：

- 使用位图
- 为 `key` 设置过期时间
- 使用 `SORT` 排序
- 使用 `pipelines` 管道
- 理解 `Redis` 中的事务
- 使用 `PubSub` 发布订阅模式
- 使用 `Lua`
- 调试 `Lua`

---

## 3.0 简介

`Redis` 除了第二章介绍的数据类型外，还提供了不少实用的数据特性，理解这些特性能让今后的工作更轻松。本章主要介绍并演示以下特性：

|         数据特性         | 演示内容                                                     |
| :----------------------: | ------------------------------------------------------------ |
|   位图（**Bitmaps**）    | 演示位图在一定条件下替代字符串以节省内存空间的操作方法       |
| 有效期（**Expiration**） | `Redis` 作为内存数据库常被用作缓存，因此必须对瞬态数据设置过期时间。本章演示了对 `key` 设置过期时间的方法 |
|   排序（**Sorting**）    | 演示 `SORT` 命令的使用                                       |
|   管道（**Pipeline**）   | 演示 `Redis` 管道的使用，弄清它在多条命令执行方面能提升性能的具体原因 |
| 事务（**Transactions**） | `Redis` 支持类似 `RDBMS` 的事务操作，但又不同于 `RDBMS`，本章将进行演示； |
|  发布订阅（**PUBSUB**）  | `Redis` 可以看作是一个消息交换的渠道，本章演示 `Redis` 发布订阅模式的简单应用 |
|   编写/调试 `Lua` 代码   | `Lua` 是一种旨在嵌入其它应用程序的脚本语言，可用于捆绑几个操作并使其原子化。示例将演示 `Lua` 脚本的编写、执行与调试 |





## 3.1 使用位图（`Bitmaps`）

位图是一个 `bit` 位的数组（也叫位数组、位向量）。`Redis` 位图不是新的数据类型，其底层数据结构还是 `string` 字符型。由于字符串本就是一个二进制大对象（`blob`），因此可以视为位图。在一定情况下，使用位图来存储布尔值信息可以节省大量的内存空间。

本节将利用位图来存储一个标志位，用于记录顾客是否使用过 `Relp` 示例应用上的某个功能。假设 `Relp` 的用户都有一个唯一且递增编号的身份 `id`，此 `id` 就可以用位图的偏移量（`offset`）来表示；而标志位是一个布尔型的属性值，可以用位图的位值来表示。

演示如下：

```bash
# SETBIT key offset value
127.0.0.1:6379> SETBIT "users_tried_reservation" 100 1
(integer) 0
# GETBIT key offset
127.0.0.1:6379> GETBIT "users_tried_online_orders" 400
(integer) 0
127.0.0.1:6379> BITCOUNT "users_tried_reservation"
(integer) 1
# BITOP operation destkey key [key ...]
127.0.0.1:6379> BITOP AND "users_tried_both_reservation_and_online_orders" "users_tried_reservation" "users_tried_online_orders"
(integer) 13
# BITCOUNT key [start end [BYTE|BIT]]
127.0.0.1:6379> BITCOUNT "users_tried_both_reservation_and_online_orders"
(integer) 0
127.0.0.1:6379>
```

其中，`BITOP` 后可跟 `AND`、`OR`、`XOR`、`NOT` 运算符，分别表示进行位与、位或、位异或、位非运算，然后将结果存入第一个 `key` 中。代码第 10 行表示查询同时使用过 **餐厅预订** 和 **在线下单** 的用户 ID。

`Redis` 中的位图数据结构示意图如下：

![img](assets/c3-1.png)



> **知识拓展**

上例中也可以使用 set 集合来计数。接下来从内存使用情况对比两者的差别。

位图中，每个用户无论是否用过该功能，都会占用一个 `bit` 位。假设 `Relp` 用户数有 20 亿，则需要分配 20 亿 `bit` 位内存（约 250 `MB`）。换用 `Redis` 集合，则只需要对使用过功能的用户 `ID` 进行存储。假设用户 `ID` 是以 8 个字节的整数进行存储，且约 80% 的用户使用过 `Relp` 这款应用，则将占用近 12.8 **GB** 的内存。当集合中的元素非常大时，位图较集合更节省内存资源。但如果 `Relp` 不那么火，则使用集合更合理。比如使用率仅为 1%，则两千万个 ID 只需要 160 MB 空间，而位图还是需要 250 MB 内存，且值的分布更稀疏（假设位图中的值是均匀分布的）。

由于在稀疏位图设置位值可能阻断 `Redis` 服务器运行一段时间，尤其是偏移量巨大而位图存的值又不多的情形。此时 `Redis` 必须即刻分配内存以扩大位图本身。

`Redis` 位图的更多用法，详见：https://redis.io/topics/data-types-intro 



## 3.2 为 `key` 设置过期时间

