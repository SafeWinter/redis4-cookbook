# 第二章 `Redis` 数据类型



相关主题：

- `string` 字符串型
- `list` 列表型
- `hash` 散列型
- `set` 集合型
- `sorted set` 有序集合型
- `HyperLogLog` 型
- `Geo` 型
- 键（`keys`）的管理

---

## 简介

数据类型是 `Redis` 应用设计与开发的核心概念。`Redis` 没有像关系型数据库那样的表（`table`）或模式（`schema`）的概念，在考虑怎样用 `Redis` 组织业务数据时，首先要考虑的一点是 `Redis` 的哪一种原生数据类型最适合当前的应用场景。`Redis` 中也没有 `SQL` 语句可供操作，而是借助数据类型本身的 `API` 接口执行各种命令，因此需要重点考虑的第二点，是这些数据类型提供的各类操作，能否能满足实际的业务需求。

本章将围绕一个称为 `Relp` 的演示项目介绍 Redis 的各类数据类型。 `Relp` 是一款用户评价和推荐顶级餐厅、购物中心和其他本地服务的应用。利用 `Relp` 可以浏览城市中的各种餐厅，查找一定距离内的排名前十的体育馆，发布本地服务的评分和评论等。`Relp` 中的所有数据都将在 `Redis` 中完成存储和操作。



## 2.1 `string` 字符串型

`Redis` 中的 `string` 字符串型数据是最基础的数据类型，其中所有的键（`keys`）都是 `string` 类型：

```bash
# start redis and connect with redis-cli
$ cd /redis/
$ ./bin/redis-server conf/redis.conf
root@TX2:/redis# ps -ef | grep redis
root       104     1  0 21:52 ?        00:00:00 ./bin/redis-server 127.0.0.1:6379
root       110    11  0 21:52 tty1     00:00:00 grep --color=auto redis
$ ./bin/redis-cli
127.0.0.1:6379> 
# SET key value
127.0.0.1:6379> SET "Extreme Pizza" "300 Broadway, New York, NY"
OK
# GET key
127.0.0.1:6379> GET "Extreme Pizza"
"300 Broadway, New York, NY"
# Get unknownKey
127.0.0.1:6379> GET "Yummy Pizza"
(nil)
# STRLEN key
127.0.0.1:6379> STRLEN "Extreme Pizza"
(integer) 26
# APPEND key appendValue
127.0.0.1:6379> APPEND "Extreme Pizza" " 10011"
(integer) 32
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, New York, NY 10011"
# SETRANGE key offset newValue (0-based offset)
127.0.0.1:6379> setrange "Extreme Pizza" 14 "Washington, DC 20009"
(integer) 34
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
127.0.0.1:6379>
```

`SET` 命令语法：`SET <key> <value>`；操作成功则返回 `OK`。

`APPEND` 命令是在已有 `key` 的值末尾追加一个新值，同时返回该 `key` 的完整值的长度；追加一个不存在的 `key` 则，相当于执行 `SET`，返回的是新值的长度。

`SETRANGE` 命令则可以替换部分值，从指定索引（从 0 开始）到原值末尾的部分，都将被替换成新值，与 `APPEND` 类似，返回的是操作完成后，新的完整值的长度。

判定一个 `key` 是否存在：`EXISTS key_name`：存在返回 1，否则返回 0：

```bash
127.0.0.1:6379> EXISTS "Extreme Pizza"
(integer) 1
127.0.0.1:6379> EXISTS "Yummy Pizza"
(integer) 0
127.0.0.1:6379> 
```

`SET` 与 `EXISTS` 相结合，即 `SETNX`（ `SET` if `N`ot e`X`ists 的缩写），`key` 存在则返回 `0`，不存在则设为新值后，返回 `1`：

```bash
# for unknown key
127.0.0.1:6379> setnx "Lobster Palace" "437 Main St, Chicago, IL"
(integer) 1
# for existed key
127.0.0.1:6379> setnx "Extreme Pizza" "100 Broadway, New York, NY"
(integer) 0
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
```

`SETNX` 还有一种写法是在 `SET` 后跟 `NX` 标识（不区分大小写），对已经存在的 `key` 返回 `(nil)`：

```bash
# for existed key
127.0.0.1:6379> set "Extreme Pizza" "abc" NX
(nil)
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
# lower case keeps the same
127.0.0.1:6379> set "Extreme Pizza" "abc" nx
(nil)
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
# for unknown key
127.0.0.1:6379> set abcd "abcd" nx
OK
127.0.0.1:6379> get abcd
"abcd"
```

与 `NX` 标识相反的标识为 `XX`，表示仅在 `key` 存在时更新为指定的新值。

还可以批量 `SET` 值或 `GET` 值，使用 `MSET` 或 `MGET`：

```bash
# MSET key value [key value ...]
127.0.0.1:6379> MSET "Sakura Sushi" "123 Ellis St, Chicago, IL" "Green Curry Thai" "456 American Way, Seattle, WA"
OK
# MGET key [key ...]
127.0.0.1:6379> MGET "Sakura Sushi" "Green Curry Thai" "nonexistent"
1) "123 Ellis St, Chicago, IL"
2) "456 American Way, Seattle, WA"
3) (nil)
```

同理，在 `key` 不存在时才批量执行 `SET`，有命令 `MSETNX`。

批量操作的好处，是将多个单一的 `SET` 命令变为一个原子性的 `MSET` 命令操作，可节省多次操作的网络开销（`network overhead`）。

> **发散**

值得一提的是 `Redis` 对象的内部编码问题，可以通过命令 `OBJECT ENCODING` 查看，语法为：

`OBJECT ENCODING key_name`

返回值为 ——

- `"int"`：若为 64 位有符号整数，则按 `int` 编码；
- `"embstr"`：不超过 44 字节时按 `embstr` 编码（`3.x` 版为 39 字节），该编码在内存使用及性能方面更高效；
- `"raw"`：超过 44 字节时按 `raw` 编码。

```bash
# 1. int demo
127.0.0.1:6379> set myKey 12345
OK
127.0.0.1:6379> object encoding myKey
"int"
# 2. embstr demo1
127.0.0.1:6379> set myKey "a string"
OK
127.0.0.1:6379> object encoding myKey
"embstr"
# 3. embstr demo2
127.0.0.1:6379> set myKey "a long string whose length is more than 39 b"
OK
127.0.0.1:6379> strlen myKey
(integer) 44
127.0.0.1:6379> object encoding myKey
"embstr"
# 4. raw demo
127.0.0.1:6379> set myKey "a long string whose length is more than 39 by"
OK
127.0.0.1:6379> strlen myKey
(integer) 45
127.0.0.1:6379> object encoding myKey
"raw"
```

根据 [官网](https://redis.io/commands/object) 对 `OBJECT` 命令的补充，除了子命令 `ENCODING` 外，还有其他子命令，可通过 `OBJECT HELP` 查看：

```bash
127.0.0.1:6379> object help
 1) OBJECT <subcommand> [<arg> [value] [opt] ...]. Subcommands are:
 2) ENCODING <key>
 3)     Return the kind of internal representation used in order to store the value
 4)     associated with a <key>.
 5) FREQ <key>
 6)     Return the access frequency index of the <key>. The returned integer is
 7)     proportional to the logarithm of the recent access frequency of the key.
 8) IDLETIME <key>
 9)     Return the idle time of the <key>, that is the approximated number of
10)     seconds elapsed since the last access to the key.
11) REFCOUNT <key>
12)     Return the number of references of the value associated with the specified
13)     <key>.
14) HELP
15)     Prints this help.
```

更多 `string` 型数据的例子，详见 [官方文档](https://redis.io/commands#string)。



## 2.2 `list` 列表型

`list` 型数据在应用开发中很常见，用于存放一组对象，也可以用作栈（`stack`）或队列（`queue`）。`Redis` 的 `key` 对应的值可以是一个字符串列表（`list of strings`）。`Redis` 中的 `list` 型数据更像是数据结构中的双向链表（`doubly linked list`）。本节介绍该类型的基本命令及相关数据操作。

演示如下：

```bash
# start Redis server
$ cd /redis/
$ ./bin/redis-server conf/redis.conf
root@TX2:/redis# ps -ef | grep redis
root       104     1  0 21:52 ?        00:00:00 ./bin/redis-server 127.0.0.1:6379
root       110    11  0 21:52 tty1     00:00:00 grep --color=auto redis
# Connect to Redis server via redis-cli tool
$ ./bin/redis-cli
127.0.0.1:6379> 
# LPUSH: insert two restaurant names to the left end
127.0.0.1:6379> LPUSH favorite_restaurants "PF Chang's" "Olive Garden"
(integer) 2
# get all names (syntax: LRANGE key start stop)
127.0.0.1:6379> LRANGE favorite_restaurants 0 -1
1) "Olive Garden"
2) "PF Chang's"
# RPUSH: insert two restaurant names to the right end
127.0.0.1:6379> RPUSH favorite_restaurants "Outback Steakhouse" "Red Lobster"
(integer) 4
127.0.0.1:6379> LRANGE favorite_restaurants 0 -1
1) "Olive Garden"
2) "PF Chang's"
3) "Outback Steakhouse"
4) "Red Lobster"
# LINSERT: insert a new name after "PF Chang's"
127.0.0.1:6379> LINSERT favorite_restaurants AFTER "PF Chang's" "Indian Tandoor"
(integer) 5
127.0.0.1:6379> LRANGE favorite_restaurants 0 -1
1) "Olive Garden"
2) "PF Chang's"
3) "Indian Tandoor"
4) "Outback Steakhouse"
5) "Red Lobster"
# LINDEX: retrieve the name at index position 3
127.0.0.1:6379> LINDEX favorite_restaurants 3
"Outback Steakhouse"
127.0.0.1:6379>
```

由于 `Redis` 列表类似双向列表，因此以下三个命令可用于添加新元素——

- `LPUSH`：将元素添加到列表的左端
- `RPUSH`：将元素追加到列表的右端
- `LINSERT`：在列表中的参照元素（`pivotal element`）之前或之后插入元素

以上三个方法均返回新列表的长度。我们无需对 `key` 赋一个初始的空列表来添加元素，当对一个不存在的 `key` 新增列表元素时，`Redis` 会自动创建一个空列表并关联到该 `key`；同样地，也无需手动删除一个空列表的 `key`，`Redis` 会自动进行回收。

只在 `key` 存在时才新增列表元素，可以使用 `LPUSHX` 或 `RPUSHX`：

```bash
# if key abc inexists
127.0.0.1:6379> exists abc
(integer) 0
127.0.0.1:6379> LPUSHX abc "aaa"
(integer) 0
127.0.0.1:6379> RPUSHX abc "bbb"
(integer) 0
127.0.0.1:6379> LRANGE abc 0 -1
(empty array)
# if key abc exists
127.0.0.1:6379> LPUSH abc "aaabbb"
(integer) 1
127.0.0.1:6379> LPUSHX abc "aaa"
(integer) 2
127.0.0.1:6379> RPUSHX abc "bbb"
(integer) 3
127.0.0.1:6379> LRANGE abc 0 -1
1) "aaa"
2) "aaabbb"
3) "bbb"
# Empty the list to check existence of key abc
127.0.0.1:6379> LPOP abc 3
1) "aaa"
2) "aaabbb"
3) "bbb"
127.0.0.1:6379> exists abc
(integer) 0
127.0.0.1:6379> 
```

可见，对应空列表的 `key` 被 `Redis` 自动删除了。

查看列表大小，使用 `LLEN key` 命令。

如果 `key` 不存在，则按空列表处理，返回 0；如果 `key` 不对应一个列表则会报错：

```bash
# test inexisted key
127.0.0.1:6379> EXISTS abc
(integer) 0
127.0.0.1:6379> LLEN abc
(integer) 0
# test normal list
127.0.0.1:6379> LPUSH abc "aaa" "bbb" "ccc"
(integer) 3
127.0.0.1:6379> LLEN abc
(integer) 3
# test key not mapped to a list
127.0.0.1:6379> SET abc "abc"
OK
127.0.0.1:6379> LLEN abc
(error) WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379>
```

从列表删除一个元素，使用 `LPOP` 或 `RPOP` 命令，分别删除最左边或最右边的一个元素，并返回该元素。作用在一个不存在的 `key`（比如 `non_existent`）返回空（`nil`）；若连续删除多个元素，只需在 `key` 后指定数量 `count` 即可（数量可以大于列表大小，但不可为负数）：

```bash
# test 1/4: non_existent
127.0.0.1:6379> LPOP non_existent
(nil)
# test 2/4: count > list size
127.0.0.1:6379> LPUSH abc a b c
(integer) 3
127.0.0.1:6379> LPOP abc 4
1) "c"
2) "b"
3) "a"
127.0.0.1:6379> LLEN abc
(integer) 0
# test 3/4: count < 0
127.0.0.1:6379> LPUSH abc a b c
(integer) 3
127.0.0.1:6379> LPOP abc -1
(error) ERR value is out of range, must be positive
# test 4/4: count = 0
127.0.0.1:6379> LPOP abc 0
(nil)
127.0.0.1:6379> LLEN abc
(integer) 3
127.0.0.1:6379> LRANGE abc 0 -1
1) "c"
2) "b"
3) "a"
127.0.0.1:6379>
```

读取列表的元素值，单个元素通过 `LINDEX key index` 命令，多个连续元素通过 `LRANGE key start stop` 命令。

> **`Redis` 中的列表索引（`list index`）约定**
>
> 假设一个列表具有 `N` 个元素，列表索引可以从左至右按 `0` ~ `N-1` 表示；也可以从右至左按 `-1` ~ `-N` 表示。因此上述演示中的 `0` ~ `-1` 表示整个列表范围。这一点与 `Python` 中的 `list` 型数据类似。

这里介绍两个和下标相关的、用于修改列表的命令——

1. `LTRIM key start end`：按指定范围裁剪列表，去除其余元素：

```bash
127.0.0.1:6379> LRANGE favorite_restaurants 0 -1
1) "Olive Garden"
2) "PF Chang's"
3) "Indian Tandoor"
4) "Outback Steakhouse"
5) "Red Lobster"
127.0.0.1:6379> LTRIM favorite_restaurants 1 -1
OK
127.0.0.1:6379> LRANGE favorite_restaurants 0 -1
1) "PF Chang's"
2) "Indian Tandoor"
3) "Outback Steakhouse"
4) "Red Lobster"
127.0.0.1:6379>
```

2. `LSET key index value`：在列表 `key` 的指定索引位置 `index`，将元素值设置为新值 `value`：

```bash
# before LSET
127.0.0.1:6379> LINDEX favorite_restaurants 1
"Indian Tandoor"
127.0.0.1:6379> LSET favorite_restaurants 1 "Longhorn Steakhouse"
OK
# after LSET
127.0.0.1:6379> LINDEX favorite_restaurants 1
"Longhorn Steakhouse"
127.0.0.1:6379>
```



> 拓展知识

`LPOP` 和 `RPOP` 命令还有对应的阻塞版（`blocking versions`）——`BLPOP` 和 `BRPOP`，并且都和对应的非阻塞版命令一样，能分别从列表的最左端或最右端弹出一个元素。语法为：

```bash
$ BLPOP key [key ...] timeout
$ BRPOP key [key ...] timeout
```

注意，`key` 和 `timeout` 都是必选项，`key` 可以同时设置多个。它们与非阻塞版的主要区别在于：当 `key` 对应的列表为空时，执行该命令的 `Redis` 客户端会被阻塞或挂起，直到等候至以秒计的 `timeout` 时间间隔、或者从其他 `Redis` 客户端对该 `key` 新增一个或多个列表元素，以此来打破列表为空的限制。`timeout` 为 0 表示一直等下去，直到该列表非空、可以弹出一个元素为止。

Redis 的这一特性在执行调度作业的场景中十分有用：各作业方（即 `Redis` 客户端）只需在表征 `Redis` 作业列表的 `key` 上分别执行 `BLPOP` 或 `BRPOP` 命令，就能在指定的时间间隔内“监听”到作业调度方（另一个 `Redis` 客户端）的调度操作；一旦监听到作业列表加入了新的作业任务（即列表元素），作业方就会按监听的 **先后顺序** 获取到对应的作业。

演示如下：打开三个 `Redis` 客户端，分别表示调度方（`dispatcher`）和两个作业方（`worker-1`、`worker-2`），然后执行以下命令：

```bash
# in worker-1 client:
worker-1> BRPOP job_queue 0
# in worker-2 client:
worker-2> BRPOP job_queue 0
# in dispatcher client:
dispatcher> LPUSH job_queue job1 
(integer) 1
dispatcher> 
# because worker-1 run BRPOP before worker-2, worker-1 get unlocked first, while worker-2 still kept waiting
worker-1> brpop job_queue 0
1) "job_queue"
2) "job1"
(97.67s)
worker-1>
# push another 2 jobs in dispatcher client:
dispatcher> LPUSH job_queue job2 job3
(integer) 2
dispatcher>
# now worker-2 get unlocked and retrieve the first new job (job2)
worker-2> brpop job_queue 0
1) "job_queue"
2) "job2"
(112.70s)
# there's only one job left (job3)
worker-2> LRANGE job_queue 0 -1 
1) "job3"
```

列表型数据对应的 `key`，其内部编码为 `quicklist`，可通过命令 `OBJECT ENCODING` 查看：

```bash
127.0.0.1:6379> object encoding job_queue
"quicklist"
127.0.0.1:6379> 
```

列表有两个配置项：

- `list-max-ziplist-size`：列表中内部列表节点的最大尺寸。大多数情况下维持默认值即可；
- `list-compress-depth`：列表的压缩策略。如果要使用列表的头部和尾部元素，可利用此设置来获得更好的列表压缩率。

更多 `list` 介绍，详见 `Redis` 文档：https://redis.io/commands#list





## 2.3 `hash` 散列型

如同其他编程语言中的映射（`maps`）或字典（`dictionary`），`hash` 散列型数据描述了字段与值之间的映射关系。`Redis` 数据集本身就可视为一个散列型数据，就像前两节演示的那样，字符型的 `key` 分别映射到一个 `string` 型或 `list` 型数据对象。这些数据对象也可以再进行 `hash` 型数据映射，其字段或值必须为 `string` 型。为了与 `Redis` 的 `key` 区分开，本书 `hash` 型数据中的 `key` 统称为 **字段**（`field`）。`hash` 型是处理对象属性（`properties`）的理想类型，比如存储餐馆的基本信息（地址、电话号码、评分等等）。

相关命令及数据操作演示如下：

```bash
# init redis server and client
$ cd /redis
$ ./bin/redis-server conf/redis.conf
$ ./bin/redis-cli
# HMSET: set multiple keys to the hash
127.0.0.1:6379> HMSET "Kyoto Ramen" "address" "801 Mission St, San Jose, CA" "phone" "555-123-6543" "rating" "5.0"
OK
# HMGET: get multiple values
127.0.0.1:6379> HMGET "Kyoto Ramen" address phone rating
1) "801 Mission St, San Jose, CA"
2) "555-123-6543"
3) "5.0"
# HGET: get single value
127.0.0.1:6379> HGET "Kyoto Ramen" rating
"5.0"
# HEXISTS key field: check field existence
127.0.0.1:6379> HEXISTS "Kyoto Ramen" phone
(integer) 1
127.0.0.1:6379> HEXISTS "Kyoto Ramen" hours
(integer) 0
# HGETALL: get all the fields & values in a hash
127.0.0.1:6379> HGETALL "Kyoto Ramen"
1) "address"
2) "801 Mission St, San Jose, CA"
3) "phone"
4) "555-123-6543"
5) "rating"
6) "5.0"
127.0.0.1:6379>
```

注意：`HGETALL` 命令不推荐使用，原因稍后解释。

若要对一个单一字段设置一个值（更新或新增字段均可），可以使用命令 `HSET`：

```bash
127.0.0.1:6379> HSET "Kyoto Ramen" rating '4.9'
(integer) 0
127.0.0.1:6379> HSET "Kyoto Ramen" status open
(integer) 1
127.0.0.1:6379> HMGET "Kyoto Ramen" rating status
1) "4.9"
2) "open"
127.0.0.1:6379> 
```

若想删除一个或多个键值对，使用命令 `HDEL key1 key2 key3 ...`，返回实际被删的字段数（不含不存在的字段）：

```bash
127.0.0.1:6379> HDEL "Kyoto Ramen" address phone
(integer) 2
# check result
127.0.0.1:6379> HGETALL "Kyoto Ramen"
1) "rating"
2) "4.9"
3) "status"
4) "open"
127.0.0.1:6379>
```

与 `list` 型数据类似，无需初始化一个空 `hash` 到某个 `key` 后再新增字段，`Redis` 会自动完成初始化；同样地，当 `key` 对应的 `hash` 为空 `hash`，`Redis` 也会自动清理掉该 `key`。

默认情况下，`HSET` 与 `HMSET` 命令会覆盖掉之前的值。如果不希望原值被覆盖、只在新增字段时添加目标值，可以使用 `HSETNX` 命令：

```bash
127.0.0.1:6379> HEXISTS "Kyoto Ramen" phone
(integer) 0
127.0.0.1:6379> HSETNX "Kyoto Ramen" phone '555-555-0001'
(integer) 1
127.0.0.1:6379> HSETNX "Kyoto Ramen" phone '555-555-0002'
(integer) 0
127.0.0.1:6379> HGET "Kyoto Ramen" phone
"555-555-0001"
127.0.0.1:6379>
```

使用 `HMGET` 或 `HGET` 获取一个不存在的 `key` 或 `field` 的值，将返回 `(nil)`：

```bash
127.0.0.1:6379> HMGET "Kyoto Ramen" rating hours
1) "4.9"
2) (nil)
127.0.0.1:6379>  HGET "Little Sheep Mongolian" address
(nil)
127.0.0.1:6379>
```

> **为什么不推荐使用 `HGETALL`**
>
> `Redis` 的 `hash` 型数据的最大字段数为 ***2<sup>32</sup> - 1***。如果字段数过多，执行 `HGETALL` 命令可能卡死 `Redis` 服务器。此时可以使用 `HSCAN` 来增量地读取所有字段和字段值。`HSCAN` 命令是 Redis 的几个扫描命令之一（此外还有 `SCAN`、`HSCAN`、`SSCAN`、`ZSCAN`），都能增量地遍历元素，因此不会阻塞服务器。该命令是一个基于游标的（`cursor-based`）遍历器，每次调用命令都要指定一次游标位置，起始位置为 0；执行结束返回的元素列表也会携带一个新的游标，以便下一次遍历使用。
>
> `HSCAN` 语法如下：
>
> ```bash
> HSCAN key_cursor [MATCH pattern] [COUNT number]
> ```
>
> 其中 `MATCH` 选项使用 `glob` 风格的模式去匹配目标字段；而 `COUNT` 选项用于指定每次遍历返回的元素个数，默认为 10 个。实际返回的个数并非一定与 `COUNT` 一致。

以下为 `HSCAN` 命令的演示，假设要用 `HSCAN` 命令在一个上百万的大型 `hash` 型散列表内遍历所有包含 `garden` 字样的字段：

```bash
# start iteration with cursor = 0
127.0.0.1:6379> HSCAN restaurant_ratings 0 MATCH *garden* 
1) "309" 
2) 1) "panda garden" 
   2) "3.9" 
   3) "chang's garden" 
   4) "4.5" 
   5) "rice garden" 
   6) "4.8"
   ...
# the new cursor is 309, which would be used in the next iteration
127.0.0.1:6379> HSCAN restaurant_ratings 309 MATCH *garden* 
1) "0" 
2) 1) "szechuwan garden" 
   2) "4.9" 
   3) "garden wok restaurant" 
   4) "4.7" 
   5) "win garden" 
   6) "4.0" 
   7) "east garden restaurant" 
   8) "4.6"
```

此时游标重新归 0，表示整个扫描结束。

`Redis` 内部使用两种编码来存放 `hash` 型对象——

- `ziplist`：用于存储小型散列对象，以节约空间。需满足两个条件：
  - 外层键值对的个数小于常量 `list-max-ziplist-entries`（默认为 512）；
  - 对象内各个元素的大小要小于 `list-max-ziplist-value`（默认为 64 字节）
- `hashtable`：不满足 `ziplist` 编码的其他情况的默认编码。

更多 `SCAN` 命令介绍，详见 `Redis` 文档：https://redis.io/commands/scan





## 2.4 `set` 集合型

## 2.5 `sorted set` 有序集合型

## 2.6 `HyperLogLog` 型

## 2.7 `Geo` 型

## 2.8 键（`keys`）的管理

