# 第二章 `Redis` 数据类型



相关主题：

- `string` 字符串型
- `list` 列表型
- `hash` 散列型
- `set` 集合型
- `sorted set` 有序集合型
- `HyperLogLog` 型
- `Geo` 型
- 键（`keys`）的管理

---

## 简介

数据类型是 `Redis` 应用设计与开发的核心概念。`Redis` 没有像关系型数据库那样的表（`table`）或模式（`schema`）的概念，在考虑怎样用 `Redis` 组织业务数据时，首先要考虑的一点是 `Redis` 的哪一种原生数据类型最适合当前的应用场景。`Redis` 中也没有 `SQL` 语句可供操作，而是借助数据类型本身的 `API` 接口执行各种命令，因此需要重点考虑的第二点，是这些数据类型提供的各类操作，能否能满足实际的业务需求。

本章将围绕一个称为 `Relp` 的演示项目介绍 Redis 的各类数据类型。 `Relp` 是一款用户评价和推荐顶级餐厅、购物中心和其他本地服务的应用。利用 `Relp` 可以浏览城市中的各种餐厅，查找一定距离内的排名前十的体育馆，发布本地服务的评分和评论等。`Relp` 中的所有数据都将在 `Redis` 中完成存储和操作。



## 2.1 `string` 字符串型

`Redis` 中的 `string` 字符串型数据是最基础的数据类型，其中所有的键（`keys`）都是 `string` 类型：

```bash
# start redis and connect with redis-cli
$ cd /redis/
$ ./bin/redis-server conf/redis.conf
root@TX2:/redis# ps -ef | grep redis
root       104     1  0 21:52 ?        00:00:00 ./bin/redis-server 127.0.0.1:6379
root       110    11  0 21:52 tty1     00:00:00 grep --color=auto redis
$ ./bin/redis-cli
127.0.0.1:6379> 
# SET key value
127.0.0.1:6379> SET "Extreme Pizza" "300 Broadway, New York, NY"
OK
# GET key
127.0.0.1:6379> GET "Extreme Pizza"
"300 Broadway, New York, NY"
# Get unknownKey
127.0.0.1:6379> GET "Yummy Pizza"
(nil)
# STRLEN key
127.0.0.1:6379> STRLEN "Extreme Pizza"
(integer) 26
# APPEND key appendValue
127.0.0.1:6379> APPEND "Extreme Pizza" " 10011"
(integer) 32
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, New York, NY 10011"
# SETRANGE key offset newValue (0-based offset)
127.0.0.1:6379> setrange "Extreme Pizza" 14 "Washington, DC 20009"
(integer) 34
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
127.0.0.1:6379>
```

`SET` 命令语法：`SET <key> <value>`；操作成功则返回 `OK`。

`APPEND` 命令是在已有 `key` 的值末尾追加一个新值，同时返回该 `key` 的完整值的长度；追加一个不存在的 `key` 则，相当于执行 `SET`，返回的是新值的长度。

`SETRANGE` 命令则可以替换部分值，从指定索引（从 0 开始）到原值末尾的部分，都将被替换成新值，与 `APPEND` 类似，返回的是操作完成后，新的完整值的长度。

判定一个 `key` 是否存在：`EXISTS key_name`：存在返回 1，否则返回 0：

```bash
127.0.0.1:6379> EXISTS "Extreme Pizza"
(integer) 1
127.0.0.1:6379> EXISTS "Yummy Pizza"
(integer) 0
127.0.0.1:6379> 
```

`SET` 与 `EXISTS` 相结合，即 `SETNX`（ `SET` if `N`ot e`X`ists 的缩写），`key` 存在则返回 `0`，不存在则设为新值后，返回 `1`：

```bash
# for unknown key
127.0.0.1:6379> setnx "Lobster Palace" "437 Main St, Chicago, IL"
(integer) 1
# for existed key
127.0.0.1:6379> setnx "Extreme Pizza" "100 Broadway, New York, NY"
(integer) 0
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
```

`SETNX` 还有一种写法是在 `SET` 后跟 `NX` 标识（不区分大小写），对已经存在的 `key` 返回 `(nil)`：

```bash
# for existed key
127.0.0.1:6379> set "Extreme Pizza" "abc" NX
(nil)
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
# lower case keeps the same
127.0.0.1:6379> set "Extreme Pizza" "abc" nx
(nil)
127.0.0.1:6379> get "Extreme Pizza"
"300 Broadway, Washington, DC 20009"
# for unknown key
127.0.0.1:6379> set abcd "abcd" nx
OK
127.0.0.1:6379> get abcd
"abcd"
```

与 `NX` 标识相反的标识为 `XX`，表示仅在 `key` 存在时更新为指定的新值。

还可以批量 `SET` 值或 `GET` 值，使用 `MSET` 或 `MGET`：

```bash
# MSET key value [key value ...]
127.0.0.1:6379> MSET "Sakura Sushi" "123 Ellis St, Chicago, IL" "Green Curry Thai" "456 American Way, Seattle, WA"
OK
# MGET key [key ...]
127.0.0.1:6379> MGET "Sakura Sushi" "Green Curry Thai" "nonexistent"
1) "123 Ellis St, Chicago, IL"
2) "456 American Way, Seattle, WA"
3) (nil)
```

同理，在 `key` 不存在时才批量执行 `SET`，有命令 `MSETNX`。

批量操作的好处，是将多个单一的 `SET` 命令变为一个原子性的 `MSET` 命令操作，可节省多次操作的网络开销（`network overhead`）。

> **发散**

值得一提的是 `Redis` 对象的内部编码问题，可以通过命令 `OBJECT ENCODING` 查看，语法为：

`OBJECT ENCODING key_name`

返回值为 ——

- `"int"`：若为 64 位有符号整数，则按 `int` 编码；
- `"embstr"`：不超过 44 字节时按 `embstr` 编码（`3.x` 版为 39 字节），该编码在内存使用及性能方面更高效；
- `"raw"`：超过 44 字节时按 `raw` 编码。

```bash
# 1. int demo
127.0.0.1:6379> set myKey 12345
OK
127.0.0.1:6379> object encoding myKey
"int"
# 2. embstr demo1
127.0.0.1:6379> set myKey "a string"
OK
127.0.0.1:6379> object encoding myKey
"embstr"
# 3. embstr demo2
127.0.0.1:6379> set myKey "a long string whose length is more than 39 b"
OK
127.0.0.1:6379> strlen myKey
(integer) 44
127.0.0.1:6379> object encoding myKey
"embstr"
# 4. raw demo
127.0.0.1:6379> set myKey "a long string whose length is more than 39 by"
OK
127.0.0.1:6379> strlen myKey
(integer) 45
127.0.0.1:6379> object encoding myKey
"raw"
```

根据 [官网](https://redis.io/commands/object) 对 `OBJECT` 命令的补充，除了子命令 `ENCODING` 外，还有其他子命令，可通过 `OBJECT HELP` 查看：

```bash
127.0.0.1:6379> object help
 1) OBJECT <subcommand> [<arg> [value] [opt] ...]. Subcommands are:
 2) ENCODING <key>
 3)     Return the kind of internal representation used in order to store the value
 4)     associated with a <key>.
 5) FREQ <key>
 6)     Return the access frequency index of the <key>. The returned integer is
 7)     proportional to the logarithm of the recent access frequency of the key.
 8) IDLETIME <key>
 9)     Return the idle time of the <key>, that is the approximated number of
10)     seconds elapsed since the last access to the key.
11) REFCOUNT <key>
12)     Return the number of references of the value associated with the specified
13)     <key>.
14) HELP
15)     Prints this help.
```

更多 `string` 型数据的例子，详见 [官方文档](https://redis.io/commands#string)。



## 2.2 `list` 列表型



## 2.3 `hash` 散列型

## 2.4 `set` 集合型

## 2.5 `sorted set` 有序集合型

## 2.6 `HyperLogLog` 型

## 2.7 `Geo` 型

## 2.8 键（`keys`）的管理

